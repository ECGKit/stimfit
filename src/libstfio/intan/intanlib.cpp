// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

/*! \file hekalib.cpp
 *  \author Christoph Schmidt-Hieber
 *  \date 2017-03-11
 *  \brief Reads Intan Technologies CLAMP data file generated by controller GUI.
 */

/*
Mostly a C++ version of read_Intan_CLP_file.m from
http://www.intantech.com/files/Intan_CLAMP_software_compiled_v1_0.zip
as of 2016-11-05
*/

#include <vector>

#include "intanlib.h"
#include "streams.h"
#include "../recording.h"

Segment read_segment(BinaryReader& binreader) {
    Segment segment;
    binreader >> segment.waveformNumber;
    binreader >> segment.tOffset;
    binreader >> segment.startIndex;
    binreader >> segment.endIndex;
    binreader >> segment.appliedValue;

    return segment;
}

std::vector<Segment> read_waveform(BinaryReader& binreader) {
    float interval;
    binreader >> interval;
    uint16_t numSegments;
    binreader >> numSegments;
    std::vector<Segment> waveform(numSegments);
    for (std::vector<Segment>::size_type nseg=0; nseg < waveform.size(); ++nseg) {
        waveform[nseg] = read_segment(binreader);
    }
    return waveform;
}

VoltageClampSettings read_header_voltage_clamp_settings(BinaryReader& binreader) {
    VoltageClampSettings vcSettings;
    binreader >> vcSettings.holdingVoltage;
    binreader >> vcSettings.nominalResistance;
    binreader >> vcSettings.resistance;
    binreader >> vcSettings.desiredBandwidth;
    binreader >> vcSettings.actualBandwidth;
    return vcSettings;
}

CurrentClampSettings read_header_current_clamp_settings(BinaryReader& binreader) {
    CurrentClampSettings ccSettings;
    binreader >> ccSettings.holdingCurrent;
    binreader >> ccSettings.currentStepSize;
    return ccSettings;
}

HeaderSettings read_header_settings(BinaryReader& binreader) {
    HeaderSettings hSettings;
    binreader >> hSettings.enableCapacitiveCompensation;
    binreader >> hSettings.capCompensationMagnitude;
    binreader >> hSettings.filterCutoff;
    binreader >> hSettings.pipetteOffset;
    binreader >> hSettings.samplingRate;
    binreader >> hSettings.cellRs;
    binreader >> hSettings.cellRm;
    binreader >> hSettings.cellCm;
    binreader >> hSettings.isVoltageClamp;
    binreader >> hSettings.vClampX2Mode;
    if (hSettings.isVoltageClamp > 0) {
        hSettings.vcSettings = read_header_voltage_clamp_settings(binreader);
    } else {
        hSettings.ccSettings = read_header_current_clamp_settings(binreader);
    }
    hSettings.waveform = read_waveform(binreader);

    return hSettings;
}

ChannelHeader read_one_header_channel(BinaryReader& binreader) {
    ChannelHeader hChannel;
    for (unsigned int registerIndex = 0; registerIndex < MAX_REGISTERS; ++registerIndex) {
        binreader >> hChannel.registers[registerIndex];
    }
    binreader >> hChannel.differenceAmpResidual;
    binreader >> hChannel.voltageAmpResidual;
    for (unsigned int a = 0; a < 2; a++) {
        for (unsigned int b = 0; b < 4; b++) {
            binreader >> hChannel.bestCalibration[a][b].coarse;
            binreader >> hChannel.bestCalibration[a][b].fine;
        }
    }
    for (unsigned int rIndex = 0; rIndex < 5; ++rIndex) {
        binreader >> hChannel.rFeedback[rIndex];
    }
    binreader >> hChannel.desiredBandwidth;

    return hChannel;
}

ChipHeader read_one_header_chip(BinaryReader& binreader, unsigned int numChannels) {
    ChipHeader hChip;
    hChip.channels.resize(numChannels);
    for (unsigned int nchan = 0; nchan < numChannels; ++nchan) {
        hChip.channels[nchan] = read_one_header_channel(binreader);
    }
    for (unsigned int nreg = 0; nreg < 4; ++nreg) {
        binreader >> hChip.chipRegisters[nreg];
    }

    return hChip;
}

std::vector<ChipHeader> read_header_chips(BinaryReader& binreader) {
    uint16_t numChips, numChannels;
    binreader >> numChips;
    binreader >> numChannels;
    std::vector<ChipHeader> hChips(numChips);
    for (unsigned int nchip = 0; nchip < hChips.size(); ++nchip) {
        hChips[nchip] = read_one_header_chip(binreader, numChannels);
    }
    return hChips;
}

IntanHeader read_header(BinaryReader& binreader) {
    uint32_t magic_number;
    binreader >> magic_number;
    if (magic_number != MAGIC_NUMBER) {
        throw std::runtime_error("Unrecognized file type");
    }
    IntanHeader hIntan;
    binreader >> hIntan.version_major;
    binreader >> hIntan.version_minor;
    binreader >> hIntan.datatype;

    uint16_t numBytes = 0;

    switch (hIntan.datatype) {
     case 0:
         binreader >> numBytes;
         binreader >> hIntan.date_Year;
         binreader >> hIntan.date_Month;
         binreader >> hIntan.date_Day;
         binreader >> hIntan.date_Hour;
         binreader >> hIntan.date_Minute;
         binreader >> hIntan.date_Second;
         hIntan.Chips = read_header_chips(binreader);
         hIntan.Settings = read_header_settings(binreader);
         break;
     case 1:
         binreader >> hIntan.numADCs;
         binreader >> numBytes;
         binreader >> hIntan.date_Year;
         binreader >> hIntan.date_Month;
         binreader >> hIntan.date_Day;
         binreader >> hIntan.date_Hour;
         binreader >> hIntan.date_Minute;
         binreader >> hIntan.date_Second;
         binreader >> hIntan.Settings.samplingRate;
         break;
     default:
         throw std::runtime_error("Unrecognized data type");
    }
    
    uint64_t pos = binreader.currentPos();
    if (pos != numBytes) {
        throw std::runtime_error("Header NumBytes doesn't match number of bytes");
    }

    return hIntan;
}

std::vector<float> read_data(BinaryReader& binreader) {
    uint64_t bytes_remaining = binreader.bytesRemaining();
    uint64_t length = bytes_remaining / (4+4+4+4);
    std::vector<uint32_t> timestamps(length);
    std::vector<float> applied(length);
    std::vector<float> clampValues(length);
    std::vector<float> measuredData(length);
    for (unsigned int idata = 0; idata < length; ++idata) {
        binreader >> timestamps[idata];
        binreader >> applied[idata]; 
        binreader >> clampValues[idata];
        binreader >> measuredData[idata];
    }

    return measuredData;
}

std::vector<std::vector<float> > read_aux_data(BinaryReader& binreader, uint16_t numADCs) {
    uint64_t bytes_remaining = binreader.bytesRemaining();
    uint64_t length = bytes_remaining / (4+2+2+2*numADCs);
    std::vector<uint32_t> timestamps(length);
    std::vector<uint16_t> digitalIn(length);
    std::vector<uint16_t> digitalOut(length);
    std::vector<std::vector<float> > adc(numADCs);
    for (unsigned int iadc = 0; iadc < numADCs; ++iadc) {
        adc[iadc].resize(length);
    }
    for (unsigned int idata = 0; idata < length; ++idata) {
        binreader >> timestamps[idata];
        binreader >> digitalIn[idata]; 
        binreader >> digitalOut[idata];
        for (unsigned int iadc = 0; iadc < numADCs; ++iadc) {
            uint16_t tmpui;
            binreader >> tmpui;
            adc[iadc][idata] = tmpui*0.0003125 - (1<<15);
        }
    }

    return adc;
}

void stfio::importIntanFile(const std::string &fName, Recording &ReturnData, ProgressInfo& progDlg) {
    std::unique_ptr<FileInStream> fs(new FileInStream());
    fs->open(fName);

    std::unique_ptr<BinaryReader> binreader(new BinaryReader(std::move(fs)));

    IntanHeader hIntan = read_header(*binreader);
    std::vector<float> section_data;
    if (hIntan.datatype == 0) {
        section_data = read_data(*binreader);
    } else {
        std::vector<std::vector<float> > aux_data = read_aux_data(*binreader, hIntan.numADCs);
        section_data = aux_data[0];
    }
    ReturnData.resize(1);
    ReturnData[0].resize(1);
    ReturnData[0][0].resize(section_data.size());
    std::copy(section_data.begin(), section_data.end(), ReturnData[0][0].get_w().begin());

}
